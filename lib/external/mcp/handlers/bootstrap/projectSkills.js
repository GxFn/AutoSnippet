/**
 * Bootstrap â€” Phase 5.5 Project Skill è‡ªåŠ¨ç”Ÿæˆ
 *
 * å°† Bootstrap æ‰«æçš„å®è§‚ç»´åº¦å€™é€‰èšåˆä¸º Project Skillï¼Œ
 * å†™å…¥ AutoSnippet/skills/ï¼ŒAgent å¯ç›´æ¥å¼•ç”¨ã€‚
 *
 * 5 ä¸ª skillWorthy ç»´åº¦:
 *   - code-standard  â†’ project-code-standard
 *   - architecture   â†’ project-architecture
 *   - project-profile â†’ project-profile
 *   - agent-guidelines â†’ project-agent-guidelines
 *   - objc-deep-scan â†’ project-objc-deep-scan (dualOutput: åŒæ—¶äº§å‡º Candidate)
 */

import { inferTargetRole } from '../TargetClassifier.js';

// â”€â”€â”€ å€™é€‰æ–‡æ¡£è§£æ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * å°†å€™é€‰çš„ codeï¼ˆMarkdown æ–‡æ¡£ï¼‰ä¸­çš„å†…å®¹è§£æä¸ºç»“æ„åŒ–æ‘˜è¦ã€‚
 * Skill ä¸éœ€è¦å®Œæ•´ä»£ç å—ï¼Œåªéœ€å…³é”®çº¦å®šå’Œè§„åˆ™ã€‚
 *
 * @param {string} codeDoc â€” candidate.code (Markdown)
 * @returns {{ heading: string, conventions: string[], codeSnippets: string[], agentNotes: string[] }}
 */
function _parseCandidateDocForSkill(codeDoc) {
  const result = { heading: '', conventions: [], codeSnippets: [], agentNotes: [] };
  if (!codeDoc) return result;

  const lines = codeDoc.split('\n');
  let section = '';

  for (const line of lines) {
    if (line.startsWith('# ')) {
      result.heading = line.replace(/^#\s+/, '').trim();
      continue;
    }
    if (line.startsWith('## ')) {
      section = line.replace(/^##\s+/, '').trim();
      continue;
    }

    const trimmed = line.trim();
    if (!trimmed) continue;

    if (section === 'çº¦å®š' || section === 'è§„èŒƒè¦ç‚¹') {
      if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        result.conventions.push(trimmed);
      } else if (trimmed.startsWith('|') && !trimmed.match(/^\|[-\s:|]+\|$/)) {
        result.conventions.push(trimmed);
      }
    } else if (section === 'Agent æ³¨æ„äº‹é¡¹') {
      if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        result.agentNotes.push(trimmed.replace(/^[-*]\s+/, ''));
      }
    } else if (section === 'ä»£ç ç¤ºä¾‹') {
      // åªä¿ç•™ä»£ç å—çš„æ–‡ä»¶æ¥æºæ ‡è®°
      if (trimmed.startsWith('// â”€â”€') && trimmed.endsWith('â”€â”€')) {
        result.codeSnippets.push(trimmed);
      }
    }
  }

  return result;
}

// â”€â”€â”€ Skill å†…å®¹æ„å»º â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * æ ¹æ®ç»´åº¦å’Œå€™é€‰æ•°æ®æ„å»º Project Skill çš„ Markdown å†…å®¹ã€‚
 *
 * @param {object} dim â€” ç»´åº¦å®šä¹‰ { id, label, skillMeta, ... }
 * @param {Array} candidates â€” Phase 5 æå–çš„å€™é€‰æ•°ç»„
 * @param {object} context â€” { primaryLang, langStats, targetFileMap, depGraphData, guardAudit, astProjectSummary }
 * @returns {string} Skill Markdown å†…å®¹ï¼ˆä¸å« frontmatterï¼‰
 */
export function buildProjectSkillContent(dim, candidates, context) {
  switch (dim.id) {
    case 'code-standard':
      return _buildCodeStandardSkill(candidates, context);
    case 'architecture':
      return _buildArchitectureSkill(candidates, context);
    case 'project-profile':
      return _buildProjectProfileSkill(candidates, context);
    case 'agent-guidelines':
      return _buildAgentGuidelinesSkill(candidates, context);
    case 'objc-deep-scan':
      return _buildDeepScanSkill(candidates, context);
    default:
      return _buildGenericSkill(dim, candidates, context);
  }
}

function _buildCodeStandardSkill(candidates, context) {
  const lang = context.primaryLang || 'unknown';
  const lines = [
    `# Project Coding Standards (${lang})`,
    '',
    '> Auto-generated by Bootstrap scan. This skill defines the project\'s coding conventions.',
    '',
    '## Instructions for the agent',
    '',
    '1. **Always** follow these naming and file organization rules when writing new code',
    '2. Check the conventions below before creating new classes, methods, or files',
    '3. Do NOT introduce naming patterns that conflict with established project conventions',
    '',
  ];

  for (const c of candidates) {
    const parsed = _parseCandidateDocForSkill(c.code);
    // v4: æ”¯æŒ 4 ä¸ªå­ä¸»é¢˜
    const sectionTitleMap = {
      'naming': 'Naming Conventions',
      'file-organization': 'File Organization',
      'api-naming': 'API / Method Naming Style',
      'comment-style': 'Comment Language & Style',
    };
    const sectionTitle = sectionTitleMap[c.subTopic] || c.subTopic || 'Conventions';

    lines.push(`## ${sectionTitle}`, '');
    if (c.summary) lines.push(`> ${c.summary}`, '');

    if (parsed.conventions.length > 0) {
      for (const conv of parsed.conventions) lines.push(conv);
      lines.push('');
    }

    if (parsed.codeSnippets.length > 0) {
      lines.push('**Reference files:**', '');
      for (const snippet of parsed.codeSnippets) {
        lines.push(`- ${snippet.replace(/\/\/\s*â”€â”€\s*/, '').replace(/\s*â”€â”€$/, '')}`);
      }
      lines.push('');
    }

    if (parsed.agentNotes.length > 0) {
      lines.push('**Mandatory rules:**', '');
      for (const note of parsed.agentNotes) lines.push(`- â›” ${note}`);
      lines.push('');
    }
  }

  // è¡¥å……ä»£ç æ¥æºå¼•ç”¨
  const allSources = [...new Set(candidates.flatMap(c => c.sources || []))];
  if (allSources.length > 0) {
    lines.push('## Source Files', '', ...allSources.map(s => `- ${s}`), '');
  }

  return lines.join('\n');
}

function _buildArchitectureSkill(candidates, context) {
  const lang = context.primaryLang || 'unknown';
  const targetCount = Object.keys(context.targetFileMap || {}).length;
  const edgeCount = context.depGraphData?.edges?.length || 0;

  const lines = [
    `# Project Architecture (${lang})`,
    '',
    `> Auto-generated by Bootstrap scan. ${targetCount} modules, ${edgeCount} dependency edges.`,
    '',
    '## Instructions for the agent',
    '',
    '1. **Understand** the module layering before modifying cross-module code',
    '2. **Respect** dependency directions â€” do NOT introduce reverse dependencies',
    '3. New modules must declare their role (core/service/ui/test/util) explicitly',
    '4. Check the dependency graph before adding import statements across modules',
    '',
  ];

  for (const c of candidates) {
    const parsed = _parseCandidateDocForSkill(c.code);
    // v4: æ”¯æŒ 3 ä¸ªå­ä¸»é¢˜
    const sectionTitleMap = {
      'layer-overview': 'Module Layering',
      'dependency-graph': 'Dependency Graph',
      'boundary-rules': 'Module Boundary Rules',
    };
    const sectionTitle = sectionTitleMap[c.subTopic] || c.subTopic || 'Architecture';

    lines.push(`## ${sectionTitle}`, '');
    if (c.summary) lines.push(`> ${c.summary}`, '');

    if (parsed.conventions.length > 0) {
      for (const conv of parsed.conventions) lines.push(conv);
      lines.push('');
    }

    if (parsed.agentNotes.length > 0) {
      lines.push('**Boundary rules:**', '');
      for (const note of parsed.agentNotes) lines.push(`- â›” ${note}`);
      lines.push('');
    }
  }

  // AST æ¶æ„æŒ‡æ ‡
  const ast = context.astProjectSummary;
  if (ast) {
    lines.push('## Code Structure Metrics (AST)', '');
    lines.push(`- Classes/Structs: ${ast.classes.length}`);
    lines.push(`- Protocols: ${ast.protocols.length}`);
    lines.push(`- Categories/Extensions: ${ast.categories.length}`);
    if (ast.projectMetrics) {
      lines.push(`- Total methods: ${ast.projectMetrics.totalMethods}`);
      lines.push(`- Avg methods/class: ${ast.projectMetrics.avgMethodsPerClass.toFixed(1)}`);
      lines.push(`- Max nesting depth: ${ast.projectMetrics.maxNestingDepth}`);
      if (ast.projectMetrics.complexMethods?.length > 0) {
        lines.push(`- âš ï¸ High-complexity methods: ${ast.projectMetrics.complexMethods.length}`);
      }
    }
    lines.push('');
  }

  // æ¨¡å—åˆ—è¡¨
  const roleMap = {};
  for (const tn of Object.keys(context.targetFileMap || {})) {
    const role = inferTargetRole(tn);
    if (!roleMap[role]) roleMap[role] = [];
    roleMap[role].push(tn);
  }
  if (Object.keys(roleMap).length > 0) {
    lines.push('## Module Roles', '');
    for (const [role, modules] of Object.entries(roleMap)) {
      lines.push(`### ${role}`, '');
      for (const m of modules) lines.push(`- \`${m}\``);
      lines.push('');
    }
  }

  return lines.join('\n');
}

function _buildProjectProfileSkill(candidates, context) {
  const lang = context.primaryLang || 'unknown';
  const lines = [
    `# Project Profile (${lang})`,
    '',
    '> Auto-generated by Bootstrap scan. Quick reference for project overview.',
    '',
    '## Instructions for the agent',
    '',
    '1. Read this skill first to understand the project context',
    '2. Use the tech stack and module info to make informed decisions',
    '3. Reference the metrics to gauge project scale and complexity',
    '',
  ];

  for (const c of candidates) {
    const parsed = _parseCandidateDocForSkill(c.code);

    if (c.summary) lines.push(`> ${c.summary}`, '');

    // v4.2: æ”¯æŒ 8 ä¸ªå­ä¸»é¢˜
    const sectionTitleMap = {
      'overview': 'Overview',
      'tech-stack': 'Tech Stack & Conventions',
      'third-party-deps': 'Third-Party Dependencies',
      'base-extensions': 'Extension / Category Registry',
      'base-classes': 'Base Classes & Global Definitions',
      'event-hooks': 'System Event Hooks & Lifecycle',
      'infra-services': 'Infrastructure Services',
      'runtime-and-interop': 'Runtime & Language Interop',
    };
    const sectionTitle = sectionTitleMap[c.subTopic] || 'Overview';

    // project-profile çš„ bodyLines é€šå¸¸æ˜¯è¡¨æ ¼ï¼Œç›´æ¥åµŒå…¥
    if (parsed.conventions.length > 0) {
      lines.push(`## ${sectionTitle}`, '');
      for (const conv of parsed.conventions) lines.push(conv);
      lines.push('');
    }
  }

  return lines.join('\n');
}

function _buildAgentGuidelinesSkill(candidates, context) {
  const lang = context.primaryLang || 'unknown';
  const lines = [
    `# Agent Development Guidelines (${lang})`,
    '',
    '> Auto-generated by Bootstrap scan. Mandatory rules and warnings found in project code.',
    '',
    '## Instructions for the agent',
    '',
    '1. **MUST** follow all mandatory rules listed below â€” violations may cause bugs or crashes',
    '2. Check TODO/FIXME items when modifying related code',
    '3. WARNING/IMPORTANT annotations are non-negotiable constraints',
    '4. Do NOT call deprecated APIs â€” use recommended alternatives instead',
    '5. Respect all "DO NOT" / "MUST NOT" / "ç¦æ­¢" constraints found in code comments',
    '',
    '## Three Core Quality Principles (MANDATORY)',
    '',
    'ğŸ”’ **Rigor (ä¸¥è°¨æ€§)**: Every assertion must be backed by actual code evidence. Use precise class names, method names, and file paths â€” never use vague terms like "this module" or "the file".',
    '',
    'ğŸ” **Deep Insight (æ·±åº¦ç‰¹å¾æŒ–æ˜)**: Go beyond statistics. Extract design intent and technical decisions. Answer "why" not just "what". Infer architecture patterns, domain concepts, and coding conventions from context.',
    '',
    'ğŸ”— **Completeness (å®Œæ•´æ€§)**: Every code example must show the full usage chain. KVO = register + handler + remove. Notification = register + handler + post + remove. Delegate = protocol + weak property + implementation. When project code is partial, supplement with canonical industry-standard examples.', 
    '',
  ];

  for (const c of candidates) {
    const parsed = _parseCandidateDocForSkill(c.code);
    // v4.1: æ”¯æŒ 5 ä¸ªå­ä¸»é¢˜ï¼ˆæ–°å¢ coding-principlesï¼‰
    const sectionTitleMap = {
      'coding-principles': 'Core Quality Principles (MANDATORY)',
      'todo-fixme': 'TODO/FIXME Items',
      'mandatory-rules': 'Mandatory Rules (WARNING/IMPORTANT)',
      'deprecated-api': 'Deprecated APIs',
      'arch-constraints': 'Code Constraints (DO NOT / ç¦æ­¢)',
    };
    const sectionTitle = sectionTitleMap[c.subTopic] || c.subTopic || 'Guidelines';

    lines.push(`## ${sectionTitle}`, '');
    if (c.summary) lines.push(`> ${c.summary}`, '');

    if (parsed.conventions.length > 0) {
      for (const conv of parsed.conventions) lines.push(conv);
      lines.push('');
    }

    if (parsed.codeSnippets.length > 0) {
      lines.push('**Found in:**', '');
      for (const snippet of parsed.codeSnippets) {
        lines.push(`- ${snippet.replace(/\/\/\s*â”€â”€\s*/, '').replace(/\s*â”€â”€$/, '')}`);
      }
      lines.push('');
    }

    if (parsed.agentNotes.length > 0) {
      lines.push('**Agent constraints:**', '');
      for (const note of parsed.agentNotes) lines.push(`- â›” ${note}`);
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * ObjC/Swift æ·±åº¦æ‰«æ Skill â€” èšåˆå¸¸é‡/Category/Hook å…¨é‡ä¿¡æ¯
 * ç”Ÿæˆå®è§‚æ¦‚è§ˆ Skillï¼ŒAgent å¯å¿«é€ŸæŸ¥é˜…é¡¹ç›®çº§çº¦å®šã€‚
 * ç»†ç²’åº¦å†…å®¹ç”± dualOutput äº§å‡ºçš„ Candidate â†’ Recipe â†’ Snippet æ‰¿è½½ã€‚
 */
function _buildDeepScanSkill(candidates, context) {
  const lang = context.primaryLang || 'objectivec';
  const langLabel = lang === 'swift' ? 'Swift' : 'ObjC';

  const lines = [
    `# Project Deep Scan â€” Constants / Category Methods / Swizzle Hooks (${langLabel})`,
    '',
    '> Auto-generated by Bootstrap deep scan. This skill aggregates all project constants,',
    '> Foundation/UIKit Category methods (with usage frequency), and Method Swizzling hooks.',
    '',
    '## Instructions for the agent',
    '',
    '1. **Always** use project-defined constants â€” never hardcode magic numbers/strings',
    '2. **Always** use project Category/Extension methods when equivalent functionality is needed',
    '3. **Before** modifying any method that appears in the Swizzle Hooks section, check the hook implementation',
    '4. Follow the usage patterns shown below â€” they reflect the project\'s established coding style',
    '',
  ];

  // æŒ‰å­ä¸»é¢˜åˆ†ç»„
  const definesCandidates = candidates.filter(c => c.subTopic?.startsWith('defines/'));
  const categoryCandidates = candidates.filter(c => c.subTopic?.startsWith('category/'));
  const hooksCandidates = candidates.filter(c => c.subTopic === 'swizzle-hooks');

  // â”€â”€ å¸¸é‡/å®æ±‡æ€» â”€â”€
  if (definesCandidates.length > 0) {
    lines.push('## Constants & Macros', '');
    for (const c of definesCandidates) {
      const parsed = _parseCandidateDocForSkill(c.code);
      lines.push(`### ${parsed.heading || c.subTopic}`, '');
      if (c.summary) lines.push(`> ${c.summary}`, '');
      // ä¿ç•™çº¦å®š/è§„åˆ™åˆ—è¡¨ï¼ˆä¸å«å®Œæ•´ä»£ç å— â€” é‚£äº›åœ¨ Candidate/Recipe ä¸­ï¼‰
      if (parsed.conventions.length > 0) {
        for (const conv of parsed.conventions.slice(0, 20)) lines.push(conv);
        if (parsed.conventions.length > 20) lines.push(`*â€¦å¦æœ‰ ${parsed.conventions.length - 20} æ¡*`);
        lines.push('');
      }
      if (parsed.agentNotes.length > 0) {
        lines.push('**Agent Rules:**');
        for (const note of parsed.agentNotes) lines.push(`- ${note}`);
        lines.push('');
      }
    }
  }

  // â”€â”€ Category/Extension æ–¹æ³•æ±‡æ€» â”€â”€
  if (categoryCandidates.length > 0) {
    lines.push('## Category / Extension Methods', '');
    for (const c of categoryCandidates) {
      const parsed = _parseCandidateDocForSkill(c.code);
      lines.push(`### ${parsed.heading || c.subTopic}`, '');
      if (c.summary) lines.push(`> ${c.summary}`, '');
      if (parsed.conventions.length > 0) {
        for (const conv of parsed.conventions.slice(0, 30)) lines.push(conv);
        if (parsed.conventions.length > 30) lines.push(`*â€¦å¦æœ‰ ${parsed.conventions.length - 30} æ¡*`);
        lines.push('');
      }
      if (parsed.agentNotes.length > 0) {
        lines.push('**Agent Rules:**');
        for (const note of parsed.agentNotes) lines.push(`- ${note}`);
        lines.push('');
      }
    }
  }

  // â”€â”€ Swizzle Hook æ±‡æ€» â”€â”€
  if (hooksCandidates.length > 0) {
    lines.push('## Method Swizzling Hooks', '');
    for (const c of hooksCandidates) {
      const parsed = _parseCandidateDocForSkill(c.code);
      if (c.summary) lines.push(`> ${c.summary}`, '');
      if (parsed.conventions.length > 0) {
        for (const conv of parsed.conventions) lines.push(conv);
        lines.push('');
      }
      if (parsed.agentNotes.length > 0) {
        lines.push('**Agent Rules:**');
        for (const note of parsed.agentNotes) lines.push(`- ${note}`);
        lines.push('');
      }
    }
  }

  return lines.join('\n');
}

function _buildGenericSkill(dim, candidates, _context) {
  const lines = [
    `# ${dim.label}`,
    '',
    '> Auto-generated by Bootstrap scan.',
    '',
    '## Instructions for the agent',
    '',
    `1. Reference this skill for ${dim.label} guidance`,
    '',
  ];

  for (const c of candidates) {
    const parsed = _parseCandidateDocForSkill(c.code);
    lines.push(`## ${parsed.heading || c.subTopic || 'Section'}`, '');
    if (c.summary) lines.push(`> ${c.summary}`, '');
    if (parsed.conventions.length > 0) {
      for (const conv of parsed.conventions) lines.push(conv);
      lines.push('');
    }
    if (parsed.agentNotes.length > 0) {
      for (const note of parsed.agentNotes) lines.push(`- ${note}`);
      lines.push('');
    }
  }

  return lines.join('\n');
}
