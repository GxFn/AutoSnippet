---
description: AutoSnippet conventions — Skills for semantics, MCP for capabilities; do not edit Knowledge directly
alwaysApply: true
---

# AutoSnippet Conventions

These rules are aligned with `.github/copilot-instructions.md` and jointly provide the AI with basic project cognition and required guardrails.

These rules are written when installing AutoSnippet Skills (`asd install:cursor-skill`) and should be followed in Cursor sessions.

## Semantics vs capabilities

- **Skills provide semantics**: When to use, workflows, and comparisons are described in Skills. Use natural language prompts in Cursor (e.g. "scan targets", "find recipe examples", "batch extract candidates") to trigger the appropriate Skill; AI intelligently interprets your request and activates the corresponding Skill logic.
- **MCP provides capabilities**: Connection and tools are provided by MCP (`autosnippet_context_search`, `autosnippet_confirm_recipe_usage`, `autosnippet_open_create`, `autosnippet_get_targets`, `autosnippet_get_target_files`, `autosnippet_submit_candidates`). Do not hardcode URLs/HTTP in Skills.

## Project basics (for AI)

- **Project root**: directory containing `*.boxspec.json` (this repo: `AutoSnippet.boxspec.json`).
- **Knowledge base**: `AutoSnippet/` (read-only for AI).
- **Recipes**: `AutoSnippet/recipes/*.md` (Markdown + Frontmatter + Snippet/Usage Guide; path is fixed).
  - **Frontmatter required fields (7)**: `title` (English, ≤50 chars, verb-based), `trigger` (MUST start with `@`), `category` (MUST be one of: `View`, `Service`, `Tool`, `Model`, `Network`, `Storage`, `UI`, `Utility`), `language` (`swift` or `objectivec`), `summary_cn` (≤100 chars), `summary_en` (≤100 words), `headers` (complete import statements like `["import Foundation"]` or `["#import <UIKit/UIKit.h>"]`).
  - **Placeholders**: Prefer Xcode placeholders in snippets (e.g. `<#URL#>`, `<#Token#>`) and explain them in Usage Guide.
  - **Usage Guide depth**: Go beyond “When/Key Points”; include dependencies, steps/config, error handling, performance, security, pitfalls, and related Recipes when applicable.
- **Snippets**: `AutoSnippet/snippets/*.json` or root spec `list`.
- **Candidates**: `AutoSnippet/.autosnippet/candidates.json` (reviewed in Dashboard).
- **Vector index**: `AutoSnippet/.autosnippet/context/` (`asd embed`).
- **Recipe stats**: `AutoSnippet/.autosnippet/recipe-stats.json` (usage + authority).
- **Weights**: `AutoSnippet/.autosnippet/recipe-stats-weights.json` or boxspec `recipes.statsWeights`.

## Knowledge base and submission

- **Do not edit** `AutoSnippet/recipes/` or `AutoSnippet/snippets/` directly; all Recipe/Snippet changes go through Dashboard and are saved after human review.
- **Path is fixed**: Recipes are always stored in `AutoSnippet/recipes/`; this path cannot be customized.
- **Search**: When you need Recipe/docs on demand, use MCP tool `autosnippet_context_search` (pass `query`, `limit?`) or read `.cursor/skills/autosnippet-recipes/references/project-recipes-context.md`. Search returns content only; it does not trigger any adoption form.
- **Retry policy**: If an MCP call fails, do not retry within the same agent turn; fall back to static docs or already-read context.
- **Adoption form**: Tool `autosnippet_confirm_recipe_usage` shows a “confirm use?” dialog. **Meaning**: On confirm, it records one human usage (humanUsageCount +1) for the recipe and affects usage stats and authority ranking. You may **decide when to show it** (e.g. when the user explicitly says they adopt, or when you infer they have adopted the recipe). Do not show it right after presenting a recipe or when the user only asks “should I adopt?”—then just answer. Pass the recipe file name(s) (e.g. from sourcePath basename).
- **Batch scan**: Ask Cursor in natural language (e.g. "scan all targets in this project", "batch extract candidates") to trigger the batch-scan workflow. The workflow calls `autosnippet_get_targets` → `autosnippet_get_target_files` → extract per file → `autosnippet_submit_candidates` automatically.

## Recipe over code

When both a Recipe and the codebase have relevant implementations, prefer the Recipe. Recipes are the project’s agreed standard; source code may be legacy or non-standard.
