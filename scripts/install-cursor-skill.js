#!/usr/bin/env node
/**
 * å°† AutoSnippet è‡ªå¸¦çš„ Agent Skills å®‰è£…åˆ°ã€Œå½“å‰é¡¹ç›®æ ¹ã€çš„ Cursor çŽ¯å¢ƒï¼ˆé¡¹ç›®æ ¹/.cursor/skills/ï¼‰ã€‚
 * é¡¹ç›®æ ¹ï¼šä»Žå½“å‰å·¥ä½œç›®å½•å‘ä¸ŠæŸ¥æ‰¾å« AutoSnippetRoot.boxspec.json çš„ç›®å½•ï¼›æœªæ‰¾åˆ°åˆ™ç”¨å½“å‰ç›®å½•ã€‚
 * å¯¹ autosnippet-recipesï¼šä¼šä»Žé¡¹ç›® Knowledge/recipes/ï¼ˆæˆ– spec.recipes.dirï¼‰ç”Ÿæˆ references/project-recipes-context.mdï¼Œä¾› Cursor ä½œä¸ºé¡¹ç›®ä¸Šä¸‹æ–‡åŠ è½½ã€‚
 * è¿è¡Œæ–¹å¼ï¼šåœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œ npm run install:cursor-skillï¼Œæˆ– asd install:cursor-skillï¼Œæˆ– node scripts/install-cursor-skill.js
 */

const fs = require('fs');
const path = require('path');
const defaults = require('../lib/infra/defaults');

const autoSnippetRoot = path.join(__dirname, '..');
const skillsSource = path.join(autoSnippetRoot, 'skills');

let projectRoot = process.cwd();
try {
	const findPath = require(path.join(autoSnippetRoot, 'bin', 'findPath.js'));
	const found = findPath.findProjectRootSync(process.cwd());
	if (found) projectRoot = found;
} catch (err) {}

const skillsTarget = path.join(projectRoot, '.cursor', 'skills');

if (!fs.existsSync(skillsSource)) {
	console.error('âŒ æœªæ‰¾åˆ° skills ç›®å½•:', skillsSource);
	process.exit(1);
}

const skillDirs = fs.readdirSync(skillsSource, { withFileTypes: true })
	.filter(d => d.isDirectory())
	.map(d => d.name);

if (skillDirs.length === 0) {
	console.log('â„¹ï¸  skills ä¸‹æš‚æ—  skill ç›®å½•ï¼Œè·³è¿‡å®‰è£…ã€‚');
	process.exit(0);
}

if (!fs.existsSync(skillsTarget)) {
	fs.mkdirSync(skillsTarget, { recursive: true });
}

function getRecipesDir(root) {
	const specPath = path.join(root, defaults.ROOT_SPEC_FILENAME);
	if (!fs.existsSync(specPath)) return path.join(root, defaults.RECIPES_DIR);
	try {
		const spec = JSON.parse(fs.readFileSync(specPath, 'utf8'));
		const dir = spec && spec.recipes && spec.recipes.dir;
		return dir ? path.join(root, dir) : path.join(root, defaults.RECIPES_DIR);
	} catch (e) {
		return path.join(root, defaults.RECIPES_DIR);
	}
}

function collectMdFiles(dir, baseDir, list = []) {
	if (!fs.existsSync(dir)) return list;
	const entries = fs.readdirSync(dir, { withFileTypes: true });
	for (const e of entries) {
		const full = path.join(dir, e.name);
		if (e.isDirectory() && !e.name.startsWith('.')) {
			collectMdFiles(full, baseDir, list);
			continue;
		}
		if (e.isFile() && e.name.toLowerCase().endsWith('.md')) {
			list.push(path.relative(baseDir, full).replace(/\\/g, '/'));
		}
	}
	return list;
}

function buildProjectRecipesContext(projectRoot) {
	const recipesDir = getRecipesDir(projectRoot);
	if (!fs.existsSync(recipesDir)) return null;
	const mdFiles = collectMdFiles(recipesDir, recipesDir).sort();
	if (mdFiles.length === 0) return null;
	let stats = { byFile: {} };
	try {
		const recipeStats = require('../lib/recipe/recipeStats');
		stats = recipeStats.getRecipeStats(projectRoot);
	} catch (_) {}
	const byFileEntries = Object.entries(stats.byFile || {}).map(([, e]) => e);
	const parts = ['# Project Recipes Context\n', 'Generated by `asd install:cursor-skill`. Use this as the project standards and Guard context.\n'];
	for (const rel of mdFiles) {
		const full = path.join(recipesDir, rel);
		const fileKey = path.basename(rel);
		try {
			const content = fs.readFileSync(full, 'utf8');
			parts.push('\n---\n\n## Recipe: ' + rel + '\n\n');
			const entry = (stats.byFile || {})[fileKey];
			if (entry) {
				try {
					const recipeStats = require('../lib/recipe/recipeStats');
					const score = recipeStats.getAuthorityScore(entry, byFileEntries, {});
					parts.push(`*Authority: ${entry.authority ?? 0}/5 | Usage: guard=${entry.guardUsageCount ?? 0}, human=${entry.humanUsageCount ?? 0}, ai=${entry.aiUsageCount ?? 0} | Score: ${score.toFixed(2)}*\n\n`);
				} catch (_) {}
			}
			parts.push(content);
			parts.push('\n');
		} catch (err) {
			parts.push('\n---\n\n## Recipe: ' + rel + '\n\n*(read error)*\n');
		}
	}
	return parts.join('');
}

function buildCategorySlices(projectRoot) {
	const recipesDir = getRecipesDir(projectRoot);
	if (!fs.existsSync(recipesDir)) return { byCategory: {}, index: { categories: [], recipeCount: 0 } };
	const mdFiles = collectMdFiles(recipesDir, recipesDir).sort();
	const byCategory = {};
	for (const rel of mdFiles) {
		const full = path.join(recipesDir, rel);
		try {
			const content = fs.readFileSync(full, 'utf8');
			const cat = defaults.inferCategory(rel, content);
			if (!byCategory[cat]) byCategory[cat] = [];
			byCategory[cat].push({ rel, content });
		} catch (_) {}
	}
	const categories = Object.keys(byCategory).sort();
	return { byCategory, index: { categories, recipeCount: mdFiles.length } };
}

function buildSpmmapSummary(projectRoot) {
	const spmmapPath = path.join(projectRoot, defaults.SPMMAP_PATH);
	if (!fs.existsSync(spmmapPath)) return null;
	try {
		const data = JSON.parse(fs.readFileSync(spmmapPath, 'utf8'));
		const graph = data.graph || {};
		const packages = graph.packages || {};
		const edges = graph.edges || {};
		const lines = ['# SPM ä¾èµ–ç»“æž„æ‘˜è¦\n', `Generated by \`asd install:cursor-skill\`. Source: ${defaults.SPMMAP_PATH}\n`, '\n## Packages\n'];
		for (const [pkg, info] of Object.entries(packages)) {
			const targets = (info.targets || []).join(', ');
			lines.push(`- **${pkg}**: ${targets || '(no targets)'}\n`);
		}
		lines.push('\n## ä¾èµ–å…³ç³» (from â†’ to)\n');
		for (const [from, toList] of Object.entries(edges)) {
			if (Array.isArray(toList)) {
				lines.push(`- ${from} â†’ ${toList.join(', ')}\n`);
			}
		}
		return lines.join('');
	} catch (_) {
		return null;
	}
}

for (const name of skillDirs) {
	const src = path.join(skillsSource, name);
	const dest = path.join(skillsTarget, name);
	if (fs.existsSync(dest)) {
		fs.rmSync(dest, { recursive: true });
	}
	fs.cpSync(src, dest, { recursive: true });
	console.log('âœ… å·²å®‰è£… skill:', name, '->', dest);

	if (name === 'autosnippet-recipes') {
		const context = buildProjectRecipesContext(projectRoot);
		const refDir = path.join(dest, 'references');
		if (!fs.existsSync(refDir)) fs.mkdirSync(refDir, { recursive: true });
		const contextPath = path.join(refDir, 'project-recipes-context.md');
		if (context) {
			fs.writeFileSync(contextPath, context, 'utf8');
			console.log('âœ… å·²ç”Ÿæˆé¡¹ç›® Recipe ä¸Šä¸‹æ–‡:', contextPath);
		} else {
			if (fs.existsSync(contextPath)) fs.unlinkSync(contextPath);
			console.log('â„¹ï¸  é¡¹ç›®æš‚æ—  recipesï¼Œæœªç”Ÿæˆ project-recipes-context.md');
		}
		const { byCategory, index } = buildCategorySlices(projectRoot);
		if (Object.keys(byCategory).length > 0) {
			const catDir = path.join(refDir, 'by-category');
			if (!fs.existsSync(catDir)) fs.mkdirSync(catDir, { recursive: true });
			for (const [cat, items] of Object.entries(byCategory)) {
				const parts = [`# ${cat}\n\n`, `Category: ${cat}. ${items.length} recipes.\n\n`];
				for (const { rel, content } of items) {
					parts.push('\n---\n\n## ' + rel + '\n\n');
					parts.push(content);
					parts.push('\n');
				}
				fs.writeFileSync(path.join(catDir, `${cat}.md`), parts.join(''), 'utf8');
			}
			fs.writeFileSync(path.join(refDir, 'index.json'), JSON.stringify(index, null, 2), 'utf8');
			console.log('âœ… å·²ç”Ÿæˆ by-category åˆ‡ç‰‡:', index.categories.join(', '));
		}
	}
	if (name === 'autosnippet-dep-graph') {
		const summary = buildSpmmapSummary(projectRoot);
		const refDir = path.join(dest, 'references');
		if (!fs.existsSync(refDir)) fs.mkdirSync(refDir, { recursive: true });
		const summaryPath = path.join(refDir, 'spmmap-summary.md');
		if (summary) {
			fs.writeFileSync(summaryPath, summary, 'utf8');
			console.log('âœ… å·²ç”Ÿæˆ spmmap æ‘˜è¦:', summaryPath);
		} else {
			if (fs.existsSync(summaryPath)) fs.unlinkSync(summaryPath);
		}
	}
	if (name === 'autosnippet-guard') {
		const context = buildProjectRecipesContext(projectRoot);
		const refDir = path.join(dest, 'references');
		if (!fs.existsSync(refDir)) fs.mkdirSync(refDir, { recursive: true });
		const guardPath = path.join(refDir, 'guard-context.md');
		if (context) {
			const excerpt = context.length > defaults.GUARD_CONTEXT_EXCERPT_LIMIT ? context.slice(0, defaults.GUARD_CONTEXT_EXCERPT_LIMIT) + '\n\n*(æˆªæ–­ï¼Œå®Œæ•´å†…å®¹è§ autosnippet-recipes/references/project-recipes-context.md)*' : context;
			fs.writeFileSync(guardPath, excerpt, 'utf8');
			console.log('âœ… å·²ç”Ÿæˆ guard-context.md');
		} else {
			if (fs.existsSync(guardPath)) fs.unlinkSync(guardPath);
		}
	}
}

// å¯é€‰ï¼šå†™å…¥ Cursor è§„åˆ™ï¼ˆ.cursor/rules/*.mdcï¼‰ï¼Œä½¿ä¼šè¯ä¸­æŒä¹…éµå¾ª AutoSnippet çº¦å®š
const cursorRulesSource = path.join(autoSnippetRoot, 'scripts', 'cursor-rules');
const cursorRulesTarget = path.join(projectRoot, '.cursor', 'rules');
if (fs.existsSync(cursorRulesSource)) {
	const ruleFiles = fs.readdirSync(cursorRulesSource, { withFileTypes: true })
		.filter(d => d.isFile() && d.name.toLowerCase().endsWith('.mdc'))
		.map(d => d.name);
	if (ruleFiles.length > 0) {
		if (!fs.existsSync(cursorRulesTarget)) fs.mkdirSync(cursorRulesTarget, { recursive: true });
		for (const name of ruleFiles) {
			const src = path.join(cursorRulesSource, name);
			const dest = path.join(cursorRulesTarget, name);
			fs.copyFileSync(src, dest);
			console.log('âœ… å·²å®‰è£… Cursor è§„åˆ™:', name, '->', dest);
		}
	}
}

// å¯é€‰ï¼šå†™å…¥ MCP é…ç½®ï¼Œä½¿ autosnippet_context_search ç­‰å·¥å…·å¯ç”¨ï¼ˆè¿žæŽ¥å±‚å°è£…åœ¨æ­¤ï¼‰
const mcpPath = path.join(projectRoot, '.cursor', 'mcp.json');
const mcpServerScript = path.join(autoSnippetRoot, 'scripts', 'mcp-server.js');
const addMcp = process.argv.includes('--mcp');
if (addMcp && fs.existsSync(mcpServerScript)) {
	let mcp = { mcpServers: {} };
	if (fs.existsSync(mcpPath)) {
		try {
			mcp = JSON.parse(fs.readFileSync(mcpPath, 'utf8'));
			if (!mcp.mcpServers) mcp.mcpServers = {};
		} catch (_) {}
	}
	mcp.mcpServers.autosnippet = {
		type: 'stdio',
		command: 'node',
		args: [mcpServerScript],
		env: { ASD_UI_URL: process.env.ASD_UI_URL || defaults.DEFAULT_ASD_UI_URL }
	};
	fs.mkdirSync(path.dirname(mcpPath), { recursive: true });
	fs.writeFileSync(mcpPath, JSON.stringify(mcp, null, 2), 'utf8');
	console.log('âœ… å·²å†™å…¥ MCP é…ç½®:', mcpPath);
	console.log('   åœ¨ Cursor ä¸­æ˜¾ç¤ºä¸º autosnippetã€‚è¯·ç”¨ Cursor æ‰“å¼€æœ¬ç›®å½•:', projectRoot);
	console.log('   ä½¿ç”¨ MCP å·¥å…·å‰éœ€å…ˆè¿è¡Œ asd ui');
} else if (addMcp) {
	console.log('â„¹ï¸  --mcp å·²æŒ‡å®šä½† mcp-server.js ä¸å­˜åœ¨ï¼Œè·³è¿‡ MCP é…ç½®');
}

console.log('ðŸŽ¯ Cursor skills å·²å°±ç»ªï¼Œå®‰è£…åˆ°é¡¹ç›®:', projectRoot);
console.log('   é‡å¯ Cursor æˆ–æ–°å¼€ Agent å¯¹è¯åŽç”Ÿæ•ˆã€‚');
if (!addMcp) {
	console.log('   æŒ‰éœ€è¯­ä¹‰æ£€ç´¢ï¼šæ‰§è¡Œ asd install:cursor-skill --mcp å¯æ·»åŠ  MCP é…ç½®ã€‚');
}

const runEmbed = process.argv.includes('--embed');
if (runEmbed) {
	(async () => {
		try {
			const IndexingPipeline = require(path.join(autoSnippetRoot, 'lib', 'context', 'IndexingPipeline'));
			const result = await IndexingPipeline.run(projectRoot, { clear: false });
			console.log('âœ… è¯­ä¹‰ç´¢å¼•å·²æ›´æ–°ï¼ˆindexed:', result.indexed, ', skipped:', result.skipped, 'ï¼‰');
		} catch (e) {
			console.warn('âš ï¸  è¯­ä¹‰ç´¢å¼•æ›´æ–°å¤±è´¥:', e.message);
		}
	})().catch(() => process.exit(1));
}
