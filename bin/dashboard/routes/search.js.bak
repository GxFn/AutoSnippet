function registerSearchRoutes(app, ctx) {
	const { projectRoot, path, fs, AiFactory, triggerSymbol } = ctx;
	const Paths = require('../../../lib/infrastructure/config/Paths.js');
	const { analyzeContext } = require('../../../lib/search/contextAnalyzer.js');

	// ============================================================
	// 统一的搜索核心函数（共享给所有搜索 API）
	// ============================================================
	async function performUnifiedSearch(params) {
		const {
			keyword,
			targetName = null,
			currentFile = null,
			language = 'swift',
			limit = 10,
			allSearchMarks = null,
			fileContent = null // 可选的文件内容（避免重复读取）
		} = params;

		if (!keyword) {
			throw new Error('keyword is required');
		}

		const { getInstance } = require('../../../lib/context');
		const recipeStats = require('../../../lib/recipe/recipeStats');
		const service = getInstance(projectRoot);
		const rootSpec = require(Paths.getProjectSpecPath(projectRoot));

		// 1. 分析当前上下文（使用 analyzeContext 深度分析）
		const contextInfo = await analyzeContext(projectRoot, { targetName, currentFile, language });

		let vectorResults = [];
		let keywordResults = [];

		// 2. 向量搜索
		try {
			const ai = await AiFactory.getProvider(projectRoot);
			if (ai) {
				vectorResults = await service.search(keyword, { limit: limit + 5, filter: { type: 'recipe' } });
				vectorResults = vectorResults.map(r => ({ ...r, _vectorScore: r.similarity || 0 }));
			}
		} catch (e) {
			console.warn('[Unified Search] Vector search failed:', e.message);
		}

		// 3. 关键词搜索
		try {
			const recipesDir = Paths.getProjectRecipesPath(projectRoot, rootSpec);
			if (fs.existsSync(recipesDir)) {
				const keywordTerms = keyword.toLowerCase().split(/\s+/).filter(w => w.length > 1);
				
				// 从 contextInfo 获取丰富的上下文术语
				const contextTerms = [
					...contextInfo.fileInfo?.imports || [],
					...contextInfo.fileInfo?.classes || [],
					...contextInfo.targetInfo?.suggestedApis || []
				].map(t => t.toLowerCase());

				const getAllMd = (dirPath, list = []) => {
					const entries = fs.readdirSync(dirPath, { withFileTypes: true });
					for (const e of entries) {
						const full = path.join(dirPath, e.name);
						if (e.isDirectory() && !e.name.startsWith('.')) {
							getAllMd(full, list);
						} else if (e.isFile() && e.name.endsWith('.md')) {
							list.push(full);
						}
					}
					return list;
				};

				const allRecipes = getAllMd(recipesDir);
				for (const recipePath of allRecipes) {
					try {
						const content = fs.readFileSync(recipePath, 'utf8');
						const fileName = path.relative(recipesDir, recipePath).replace(/\\/g, '/');
						
						let matches = 0;
						let contextMatches = 0;
						const text = content.toLowerCase();
						const name = fileName.toLowerCase();

						// 主要关键词匹配
						for (const term of keywordTerms) {
							if (name.includes(term) || text.includes(term)) matches++;
						}

						// 上下文关键词匹配（权重更高）
						for (const contextTerm of contextTerms) {
							if (contextTerm && text.includes(contextTerm)) {
								contextMatches++;
							}
						}

						if (matches > 0 || contextMatches > 0) {
							const keywordScore = Math.min(1, (matches / Math.max(keywordTerms.length, 1)) * 0.6);
							const contextScore = Math.min(0.4, (contextMatches / Math.max(contextTerms.length, 1)) * 0.4);
							const totalScore = keywordScore + contextScore;

							keywordResults.push({
								name: fileName,
								content,
								_keywordScore: totalScore,
								_contextMatches: contextMatches,
								_isContextRelevant: contextMatches > 0
							});
						}
					} catch (e) {
						console.warn(`[Unified Search] Failed to read recipe ${recipePath}:`, e.message);
					}
				}
			}
		} catch (e) {
			console.warn('[Unified Search] Keyword search failed:', e.message);
		}

		// 4. 合并和评分
		const mergedMap = new Map();
		
		for (const vr of vectorResults) {
			const key = vr.metadata?.name || vr.id || '';
			if (!mergedMap.has(key)) {
				mergedMap.set(key, {
					name: key,
					content: vr.content || '',
					_vectorScore: vr._vectorScore,
					_keywordScore: 0,
					...vr
				});
			}
		}

		for (const kr of keywordResults) {
			if (!mergedMap.has(kr.name)) {
				mergedMap.set(kr.name, kr);
			} else {
				const existing = mergedMap.get(kr.name);
				existing._keywordScore = kr._keywordScore;
				existing._contextMatches = kr._contextMatches;
				existing._isContextRelevant = kr._isContextRelevant;
			}
		}

		// 5. 智能评分：上下文相关性加权（统一的权重配置）
		let results = Array.from(mergedMap.values()).map(item => {
			const vectorScore = item._vectorScore || 0;
			const keywordScore = item._keywordScore || 0;
			const isContextRelevant = item._isContextRelevant || false;
			
			// 统一权重：平衡的上下文加权
			const contextBoost = isContextRelevant ? 1.3 : 1.0;
			const hybridScore = (vectorScore * 0.6 + keywordScore * 0.4) * contextBoost;
			
			return { 
				...item, 
				_hybridScore: hybridScore,
				_vectorScore: vectorScore, 
				_keywordScore: keywordScore,
				isContextRelevant 
			};
		});

		// 6. 权威分加权排序
		try {
			const stats = recipeStats.getRecipeStats(projectRoot);
			const byFileEntries = Object.values(stats.byFile || {});
			
			results = results.map(item => {
				const key = path.basename(item.name);
				const entry = (stats.byFile || {})[key];
				const authorityScore = entry ? recipeStats.getAuthorityScore(entry, byFileEntries, {}) : 0;
				
				// 统一权重：平衡的得分公式
				const contextScore = item.isContextRelevant ? 0.5 : 0;
				const finalScore = item._hybridScore * 0.6 + (authorityScore || 0) * 0.3 + contextScore * 0.1;
				
				return {
					...item,
					similarity: finalScore,
					authority: entry?.authority || 0,
					usageCount: (entry?.guardUsageCount || 0) + (entry?.humanUsageCount || 0) + (entry?.aiUsageCount || 0),
					authorityScore: Math.round((authorityScore || 0) * 100) / 100,
					stats: entry ? {
						authority: entry.authority ?? 0,
						guardUsageCount: entry.guardUsageCount ?? 0,
						humanUsageCount: entry.humanUsageCount ?? 0,
						aiUsageCount: entry.aiUsageCount ?? 0,
						authorityScore: Math.round(authorityScore * 100) / 100
					} : undefined
				};
			});
		} catch (e) {
			console.warn('[Unified Search] Authority scoring failed:', e.message);
		}

		// 7. AI 多标记上下文评估（新增）
		if (allSearchMarks && Array.isArray(allSearchMarks) && allSearchMarks.length > 1) {
			try {
				const ai = await AiFactory.getProvider(projectRoot);
				if (ai) {
					const contextDescription = allSearchMarks.map((mark, idx) => 
						`搜索 ${idx + 1}: 关键词"${mark.keyword}"，代码上下文:\n${mark.context || ''}`
					).join('\n\n');

					const evalPrompt = `
用户在 Xcode 文件中有多个搜索标记：

${contextDescription}

请评估以下 Recipe 对这些搜索的整体相关性（1-100 分）：

Recipe: ${results[0]?.name || 'N/A'}
内容: ${results[0]?.content?.substring(0, 500) || 'N/A'}

只返回一个数字（1-100），表示相关性分数。
`;

					const aiEvalResult = await ai.generateText(evalPrompt, { maxTokens: 10 });
					const aiScore = parseInt(aiEvalResult.trim()) || 50;
					const aiBoost = Math.max(0, Math.min(1, aiScore / 100));

					results = results.map(r => ({
						...r,
						_aiRelevanceScore: aiScore,
						similarity: r.similarity * 0.7 + aiBoost * 0.3
					}));

					console.log(`[Unified Search] AI re-evaluated ${results.length} results, boost: ${aiBoost.toFixed(2)}`);
				}
			} catch (e) {
				console.warn('[Unified Search] AI context evaluation failed:', e.message);
			}
		}

		// 8. 排序和限制
		results.sort((a, b) => b.similarity - a.similarity);
		
		// 设置最小相似度阈值
		const minSimilarity = vectorResults.length > 0 ? 0.3 : 0.2;
		results = results.filter(r => r.similarity >= minSimilarity);
		
		results = results.slice(0, limit);

		return {
			results,
			contextInfo,
			hasAiEvaluation: allSearchMarks && Array.isArray(allSearchMarks) && allSearchMarks.length > 1
		};
	}

	// ============================================================
	// API 端点
	// ============================================================

	// API: as:search 选即插 — 在 path 文件中找到 // as:search 行并替换为 content
	app.post('/api/insert-at-search-mark', async (req, res) => {
		try {
			const { path: relativePath, content } = req.body;
			if (!relativePath || content === undefined) {
				return res.status(400).json({ error: 'path and content are required' });
			}
			const fullPath = path.resolve(projectRoot, relativePath);
			if (!fullPath.startsWith(projectRoot)) {
				return res.status(400).json({ error: 'path must be under project root' });
			}
			if (!fs.existsSync(fullPath)) {
				return res.status(404).json({ error: 'File not found' });
			}
			const raw = fs.readFileSync(fullPath, 'utf8');
			const lines = raw.split(/\r?\n/);
			const searchMark = /\/\/\s*(?:autosnippet:search|as:search|as:s)(\s|$)/;
			let found = -1;
			for (let i = 0; i < lines.length; i++) {
				const t = triggerSymbol.stripTriggerPrefix(lines[i].trim()).trim();
				if (searchMark.test(t) || t === '// as:search' || t.startsWith('// as:search ') || t === '// as:s' || t.startsWith('// as:s ') || t.startsWith('// autosnippet:search')) {
					found = i;
					break;
				}
			}
			if (found < 0) {
				return res.status(404).json({ error: 'No // as:search or // as:s line found in file' });
			}
			const insertLines = String(content).split(/\r?\n/);
			const newLines = [...lines.slice(0, found), ...insertLines, ...lines.slice(found + 1)];
			fs.writeFileSync(fullPath, newLines.join('\n'), 'utf8');
			res.json({ success: true, path: relativePath });
		} catch (err) {
			console.error('[API Error]', err);
			res.status(500).json({ error: err.message });
		}
	});

	// API: Xcode 中的搜索触发 — 从代码注释 // as:s keyword 触发搜索
	// 现在使用统一的搜索核心，获得和 context-aware 相同的高质量结果
	app.post('/api/search/trigger-from-code', async (req, res) => {
		try {
			const { filePath, lineNumber, keyword, projectName, allSearchMarks } = req.body;
			
			if (!keyword) {
				return res.status(400).json({ error: 'keyword is required' });
			}

			// 1. 提取搜索关键词
			let searchKeyword = keyword.trim();
			const searchMatch = keyword.match(/(?:as:s|as:search)\s+(.+)$/i);
			if (searchMatch) {
				searchKeyword = searchMatch[1].trim();
			}

			if (!searchKeyword) {
				return res.status(400).json({ error: 'No keyword found in search mark' });
			}

			// 2. 推断 Target（从文件路径）
			let inferredTargetName = null;
			if (filePath) {
				const pathParts = filePath.split('/');
				const sourcesIdx = pathParts.indexOf('Sources');
				if (sourcesIdx > 0) {
					inferredTargetName = pathParts[sourcesIdx - 1];
				} else {
					const fileName = pathParts[pathParts.length - 1] || '';
					const nameMatch = fileName.match(/^([A-Z][a-zA-Z]+)/);
					if (nameMatch) {
						inferredTargetName = nameMatch[1];
					}
				}
			}

			// 3. 读取文件内容（作为可选参数传入）
			let fileContent = '';
			if (filePath) {
				const fullPath = path.resolve(projectRoot, filePath);
				if (fs.existsSync(fullPath)) {
					try {
						fileContent = fs.readFileSync(fullPath, 'utf8');
					} catch (e) {
						console.warn('[Trigger from Code] Failed to read file:', e.message);
					}
				}
			}

			// 4. 调用统一的搜索核心（使用 analyzeContext 进行深度分析）
			const { results, contextInfo, hasAiEvaluation } = await performUnifiedSearch({
				keyword: searchKeyword,
				targetName: inferredTargetName,
				currentFile: filePath,
				language: 'swift',
				limit: 8,  // Xcode 优化
				allSearchMarks: allSearchMarks,
				fileContent: fileContent
			});

			// 5. 清理结果为 Xcode 格式
			const cleanResults = results.map(r => ({
				name: r.name,
				snippet: r.content ? r.content.substring(0, 300) : '',
				similarity: Math.round(r.similarity * 100),
				isContextRelevant: r.isContextRelevant,
				authority: Math.round(r.authority * 100) / 100,
				usageCount: r.usageCount,
				stats: r.stats,
				aiRelevanceScore: r._aiRelevanceScore ? Math.round(r._aiRelevanceScore) : undefined
			}));

			res.json({ 
				success: true,
				keyword: searchKeyword,
				targetName: inferredTargetName,
				results: cleanResults,
				total: cleanResults.length,
				hasAiEvaluation: hasAiEvaluation,
				searchTime: Date.now()
			});
		} catch (err) {
			console.error('[Trigger from Code Error]', err);
			res.status(500).json({ error: err.message });
		}
	});
			
			if (!keyword) {
				return res.status(400).json({ error: 'keyword is required' });
			}

			// 提取搜索关键词（支持 // as:s keyword 格式）
			let searchKeyword = keyword.trim();
			
			// 处理 // as:s 或 // as:search 后面的内容
			const searchMatch = keyword.match(/(?:as:s|as:search)\s+(.+)$/i);
			if (searchMatch) {
				searchKeyword = searchMatch[1].trim();
			}

			if (!searchKeyword) {
				return res.status(400).json({ error: 'No keyword found in search mark' });
			}

			// 1. 尝试从文件路径推断 Target 名称
			let inferredTargetName = null;
			if (filePath) {
				// 常见的 Target 结构：.../BDNetwork/Sources/... 或 .../Sources/BDNetwork/...
				const pathParts = filePath.split('/');
				const sourcesIdx = pathParts.indexOf('Sources');
				if (sourcesIdx > 0) {
					inferredTargetName = pathParts[sourcesIdx - 1];
				} else {
					// 尝试从文件名中推断
					const fileName = pathParts[pathParts.length - 1] || '';
					const nameMatch = fileName.match(/^([A-Z][a-zA-Z]+)/);
					if (nameMatch) {
						inferredTargetName = nameMatch[1];
					}
				}
			}

			// 2. 读取文件内容以提取上下文
			let fileContent = '';
			if (filePath) {
				const fullPath = path.resolve(projectRoot, filePath);
				if (fs.existsSync(fullPath)) {
					try {
						fileContent = fs.readFileSync(fullPath, 'utf8');
					} catch (e) {
						console.warn('[Search Trigger] Failed to read file:', e.message);
					}
				}
			}

			// 3. 调用上下文感知搜索
			const searchPayload = {
				keyword: searchKeyword,
				targetName: inferredTargetName,
				currentFile: filePath,
				language: 'swift', // 默认 Swift，可根据文件扩展名调整
				limit: 8 // Xcode 中显示 8 个结果
			};

			// 执行搜索（调用现有的混合搜索逻辑）
			const { getInstance } = require('../../../lib/context');
			const recipeStats = require('../../../lib/recipe/recipeStats');
			const service = getInstance(projectRoot);
			const rootSpec = require(Paths.getProjectSpecPath(projectRoot));

			let vectorResults = [];
			let keywordResults = [];

			// 向量搜索
			try {
				const ai = await AiFactory.getProvider(projectRoot);
				if (ai) {
					vectorResults = await service.search(searchKeyword, { limit: 15, filter: { type: 'recipe' } });
					vectorResults = vectorResults.map(r => ({ ...r, _vectorScore: r.similarity || 0 }));
				}
			} catch (e) {
				console.warn('[Search Trigger] Vector search failed:', e.message);
			}

			// 关键词搜索
			try {
				const recipesDir = Paths.getProjectRecipesPath(projectRoot, rootSpec);
				if (fs.existsSync(recipesDir)) {
					const keywordTerms = searchKeyword.toLowerCase().split(/\s+/).filter(w => w.length > 1);
					const contextTerms = [];
					
					// 从文件内容提取导入
					if (fileContent) {
						const importMatches = fileContent.match(/import\s+(\w+)/g) || [];
						importMatches.forEach(m => {
							const framework = m.replace('import ', '').trim();
							if (framework) contextTerms.push(framework.toLowerCase());
						});
					}

					const getAllMd = (dirPath, list = []) => {
						const entries = fs.readdirSync(dirPath, { withFileTypes: true });
						for (const e of entries) {
							const full = path.join(dirPath, e.name);
							if (e.isDirectory() && !e.name.startsWith('.')) {
								getAllMd(full, list);
							} else if (e.isFile() && e.name.endsWith('.md')) {
								list.push(full);
							}
						}
						return list;
					};

					const allRecipes = getAllMd(recipesDir);
					for (const filePath of allRecipes) {
						try {
							const content = fs.readFileSync(filePath, 'utf8');
							const fileName = path.relative(recipesDir, filePath).replace(/\\/g, '/');
							
							let matches = 0;
							let contextMatches = 0;
							const text = content.toLowerCase();
							const name = fileName.toLowerCase();

							// 主要关键词匹配
							for (const term of keywordTerms) {
								if (name.includes(term) || text.includes(term)) matches++;
							}

							// 上下文关键词匹配
							for (const contextTerm of contextTerms) {
								if (contextTerm && text.includes(contextTerm)) {
									contextMatches++;
								}
							}

							if (matches > 0 || contextMatches > 0) {
								const keywordScore = Math.min(1, (matches / Math.max(keywordTerms.length, 1)) * 0.6);
								const contextScore = Math.min(0.4, (contextMatches / Math.max(contextTerms.length, 1)) * 0.4);
								const totalScore = keywordScore + contextScore;

								keywordResults.push({
									name: fileName,
									content,
									_keywordScore: totalScore,
									_contextMatches: contextMatches,
									_isContextRelevant: contextMatches > 0
								});
							}
						} catch (e) {
							console.warn(`[Search Trigger] Failed to read recipe ${filePath}:`, e.message);
						}
					}
				}
			} catch (e) {
				console.warn('[Search Trigger] Keyword search failed:', e.message);
			}

			// 4. 合并和评分
			const mergedMap = new Map();
			
			for (const vr of vectorResults) {
				const key = vr.metadata?.name || vr.id || '';
				if (!mergedMap.has(key)) {
					mergedMap.set(key, {
						name: key,
						content: vr.content || '',
						_vectorScore: vr._vectorScore,
						_keywordScore: 0,
						...vr
					});
				}
			}

			for (const kr of keywordResults) {
				if (!mergedMap.has(kr.name)) {
					mergedMap.set(kr.name, kr);
				} else {
					const existing = mergedMap.get(kr.name);
					existing._keywordScore = kr._keywordScore;
					existing._contextMatches = kr._contextMatches;
					existing._isContextRelevant = kr._isContextRelevant;
				}
			}

			// 5. 智能评分（优化用于 Xcode 搜索）
			let results = Array.from(mergedMap.values()).map(item => {
				const vectorScore = item._vectorScore || 0;
				const keywordScore = item._keywordScore || 0;
				const isContextRelevant = item._isContextRelevant || false;
				
				// 优化：提升上下文权重，更好地过滤无关结果
				const contextBoost = isContextRelevant ? 1.5 : 0.8;  // 原: 1.3 / 1.0
				
				// 优化：向量搜索权重提升（向量更精准），关键词权重降低
				const hybridScore = (vectorScore * 0.7 + keywordScore * 0.3) * contextBoost;  // 原: 0.6 + 0.4
				
				return { 
					...item, 
					_hybridScore: hybridScore,
					_vectorScore: vectorScore, 
					_keywordScore: keywordScore,
					isContextRelevant 
				};
			});

			// 6. 权威分加权排序（优化用于 Xcode）
			try {
				const stats = recipeStats.getRecipeStats(projectRoot);
				const byFileEntries = Object.values(stats.byFile || {});
				
				results = results.map(item => {
					const key = path.basename(item.name);
					const entry = (stats.byFile || {})[key];
					const authorityScore = entry ? recipeStats.getAuthorityScore(entry, byFileEntries, {}) : 0;
					
					// 优化：提升权威分权重（经过验证的 Recipe 更可靠）
					// 原: 混合*0.6 + 权威*0.3 + 上下文*0.1
					// 新: 混合*0.5 + 权威*0.35 + 上下文*0.15
					const contextScore = item.isContextRelevant ? 0.8 : 0;  // 原: 0.5 / 0
					const finalScore = item._hybridScore * 0.5 + (authorityScore || 0) * 0.35 + contextScore * 0.15;
					
					return {
						...item,
						similarity: finalScore,
						authority: entry?.authority || 0,
						usageCount: (entry?.guardUsageCount || 0) + (entry?.humanUsageCount || 0) + (entry?.aiUsageCount || 0),
						authorityScore: Math.round((authorityScore || 0) * 100) / 100,
						stats: entry ? {
							authority: entry.authority ?? 0,
							guardUsageCount: entry.guardUsageCount ?? 0,
							humanUsageCount: entry.humanUsageCount ?? 0,
							aiUsageCount: entry.aiUsageCount ?? 0,
							authorityScore: Math.round(authorityScore * 100) / 100
						} : undefined
					};
				});
			} catch (e) {
				console.warn('[Search Trigger] Authority scoring failed:', e.message);
			}

			// 7. AI 多标记上下文评估（新增）
			// 如果提供了 allSearchMarks，使用 AI 对搜索结果进行再评估
			if (allSearchMarks && Array.isArray(allSearchMarks) && allSearchMarks.length > 1) {
				try {
					const ai = await AiFactory.getProvider(projectRoot);
					if (ai) {
						// 构建上下文描述
						const contextDescription = allSearchMarks.map((mark, idx) => 
							`搜索 ${idx + 1}: 关键词"${mark.keyword}"，代码上下文:\n${mark.context || ''}`
						).join('\n\n');

						// 对每个结果进行 AI 评估
						const evalPrompt = `
用户在 Xcode 文件中有多个搜索标记：

${contextDescription}

请评估以下 Recipe 对这些搜索的整体相关性（1-100 分）：

Recipe: ${results[0]?.name || 'N/A'}
内容: ${results[0]?.content?.substring(0, 500) || 'N/A'}

只返回一个数字（1-100），表示相关性分数。
`;

						const aiEvalResult = await ai.generateText(evalPrompt, { maxTokens: 10 });
						const aiScore = parseInt(aiEvalResult.trim()) || 50;
						const aiBoost = Math.max(0, Math.min(1, aiScore / 100));

						// 对结果应用 AI 评估加权
						results = results.map(r => ({
							...r,
							_aiRelevanceScore: aiScore,
							similarity: r.similarity * 0.7 + aiBoost * 0.3  // 70% 原始分数 + 30% AI 评估
						}));

						console.log(`[Search Trigger] AI re-evaluated ${results.length} results, boost: ${aiBoost.toFixed(2)}`);
					}
				} catch (e) {
					console.warn('[Search Trigger] AI context evaluation failed:', e.message);
					// 如果 AI 评估失败，继续使用原始分数
				}
			}

			// 8. 排序和限制
			// 优化：两阶段排序
			// 1) 先按相似度排序
			results.sort((a, b) => b.similarity - a.similarity);
			
			// 2) 设置最小相似度阈值，过滤掉明显无关的结果（可选）
			// 如果没有向量搜索结果，放宽阈值
			const minSimilarity = vectorResults.length > 0 ? 0.3 : 0.2;
			results = results.filter(r => r.similarity >= minSimilarity);
			
			// 3) 限制返回数量
			results = results.slice(0, 8); // Xcode 中最多显示 8 个结果

		// 9. 清理结果，为 Xcode 返回优化的格式
		const cleanResults = results.map(r => ({
			name: r.name,
			snippet: r.content ? r.content.substring(0, 300) : '', // 摘要
			similarity: Math.round(r.similarity * 100), // 百分比
			isContextRelevant: r.isContextRelevant,
			authority: Math.round(r.authority * 100) / 100,
			usageCount: r.usageCount,
			stats: r.stats,
			aiRelevanceScore: r._aiRelevanceScore ? Math.round(r._aiRelevanceScore) : undefined  // AI 评估分数
		}));

		res.json({ 
			success: true,
			keyword: searchKeyword,
			targetName: inferredTargetName,
			results: cleanResults,
			total: cleanResults.length,
			hasAiEvaluation: allSearchMarks && Array.isArray(allSearchMarks) && allSearchMarks.length > 1,
				searchTime: Date.now()
			});
		} catch (err) {
			console.error('[Search Trigger Error]', err);
			res.status(500).json({ error: err.message });
		}
	});

	// API: 上下文语义搜索（供 Agent/Skill 调用），返回项合并 recipe-stats 供 AI 可见
	app.post('/api/context/search', async (req, res) => {
		try {
			const { query, limit = 5, filter } = req.body;
			if (!query || typeof query !== 'string') {
				return res.status(400).json({ error: 'query is required and must be a string' });
			}
			const { getInstance } = require('../../../lib/context');
			const ai = await AiFactory.getProvider(projectRoot);
			if (!ai) return res.status(400).json({ error: 'AI 未配置，无法进行语义检索' });
			const service = getInstance(projectRoot);
			let items = await service.search(query, { limit, filter });
			try {
				const recipeStats = require('../../../lib/recipe/recipeStats');
				// MCP/Agent 引用：本次搜索返回的 Recipe 记一次 ai 使用
				for (const it of items) {
					const meta = it.metadata || {};
					if (meta.type !== 'recipe') continue;
					const sourcePath = meta.sourcePath || meta.source || it.id || '';
					const fileKey = sourcePath ? path.basename(sourcePath) : null;
					if (fileKey) recipeStats.recordRecipeUsage(projectRoot, { recipeFilePath: fileKey, source: 'ai' });
				}
				const stats = recipeStats.getRecipeStats(projectRoot);
				const byFileEntries = Object.values(stats.byFile || {});
				items = items.map((it) => {
					const meta = it.metadata || {};
					const fileKey = path.basename(meta.sourcePath || meta.source || it.id || '');
					const entry = fileKey ? (stats.byFile || {})[fileKey] : null;
					if (!entry) return it;
					const score = recipeStats.getAuthorityScore(entry, byFileEntries, {});
					return {
						...it,
						stats: {
							authority: entry.authority ?? 0,
							guardUsageCount: entry.guardUsageCount ?? 0,
							humanUsageCount: entry.humanUsageCount ?? 0,
							aiUsageCount: entry.aiUsageCount ?? 0,
							authorityScore: Math.round(score * 100) / 100
						}
					};
				});
			} catch (_) {}
			res.json({ items });
		} catch (err) {
			console.error('[API Error]', err);
			res.status(500).json({ error: err.message });
		}
	});

	// API: 上下文感知搜索 — 基于当前文件/target 的智能推荐
	app.post('/api/search/context-aware', async (req, res) => {
		try {
			const { keyword, targetName, currentFile, language, limit = 10, allSearchMarks } = req.body;
			if (!keyword) return res.status(400).json({ error: 'Keyword is required' });

			// 使用统一的搜索核心
			const { results, contextInfo, hasAiEvaluation } = await performUnifiedSearch({
				keyword,
				targetName,
				currentFile,
				language,
				limit,
				allSearchMarks
			});

			// 格式化结果供 Dashboard 使用
			const cleanResults = results.map(r => ({
				name: r.name,
				content: r.content,
				similarity: Math.round(r.similarity * 100) / 100,
				authority: r.authority,
				usageCount: r.usageCount,
				stats: r.stats,
				isContextRelevant: r.isContextRelevant,
				matchType: r._vectorScore > r._keywordScore ? 'semantic' : 'keyword',
				metadata: r.metadata,
				aiRelevanceScore: r.aiRelevanceScore // 多标记 AI 评分
			}));

			res.json({ 
				results: cleanResults,
				context: contextInfo,
				total: cleanResults.length,
				hasAiEvaluation,
				searchTime: Date.now()
			});
		} catch (err) {
			console.error('[API Error]', err);
			res.status(500).json({ error: err.message });
		}
	});

	// API: 混合搜索（向量 + 关键词 + 权威分）- 最佳搜索体验
	app.post('/api/search/hybrid', async (req, res) => {
		try {
			const { keyword, limit = 10, category, language } = req.body;
			if (!keyword) return res.status(400).json({ error: 'Keyword is required' });

			const { getInstance } = require('../../../lib/context');
			const recipeStats = require('../../../lib/recipe/recipeStats');

			const service = getInstance(projectRoot);
			const rootSpec = require(Paths.getProjectSpecPath(projectRoot));

			let vectorResults = [];
			let keywordResults = [];

			// 1. 尝试向量搜索
			try {
				const ai = await AiFactory.getProvider(projectRoot);
				if (ai) {
					vectorResults = await service.search(keyword, { limit: limit + 5, filter: { type: 'recipe' } });
					vectorResults = vectorResults.map(r => ({ ...r, _vectorScore: r.similarity || 0 }));
				}
			} catch (e) {
				console.warn('[Hybrid Search] Vector search failed:', e.message);
			}

			// 2. 关键词搜索（回退 + 补充）
			try {
				const recipesDir = Paths.getProjectRecipesPath(projectRoot, rootSpec);
				if (fs.existsSync(recipesDir)) {
					const keywordTerms = keyword.toLowerCase().split(/\s+/).filter(w => w.length > 1);
					const getAllMd = (dirPath, list = []) => {
						const entries = fs.readdirSync(dirPath, { withFileTypes: true });
						for (const e of entries) {
							const full = path.join(dirPath, e.name);
							if (e.isDirectory() && !e.name.startsWith('.')) {
								getAllMd(full, list);
							} else if (e.isFile() && e.name.endsWith('.md')) {
								list.push(full);
							}
						}
						return list;
					};

					const allRecipes = getAllMd(recipesDir);
					for (const filePath of allRecipes) {
						const content = fs.readFileSync(filePath, 'utf8');
						const fileName = path.relative(recipesDir, filePath).replace(/\\/g, '/');
						
						// 计算关键词匹配分
						let matches = 0;
						let matchFields = [];
						const text = content.toLowerCase();
						const name = fileName.toLowerCase();

						for (const term of keywordTerms) {
							if (name.includes(term)) {
								matches++;
								matchFields.push('filename');
							} else if (text.includes(term)) {
								matches++;
								matchFields.push('content');
							}
						}

						if (matches > 0) {
							const keywordScore = Math.min(1, (matches / Math.max(keywordTerms.length, 1)) * 0.8);
							keywordResults.push({
								name: fileName,
								content,
								_keywordScore: keywordScore,
								_matchFields: [...new Set(matchFields)]
							});
						}
					}
				}
			} catch (e) {
				console.warn('[Hybrid Search] Keyword search failed:', e.message);
			}

			// 3. 合并结果（向量 + 关键词）
			const mergedMap = new Map();
			
			// 加入向量结果
			for (const vr of vectorResults) {
				const key = vr.metadata?.name || vr.id || '';
				if (!mergedMap.has(key)) {
					mergedMap.set(key, {
						name: key,
						content: vr.content || '',
						_vectorScore: vr._vectorScore,
						_keywordScore: 0,
						...vr
					});
				}
			}

			// 加入关键词结果
			for (const kr of keywordResults) {
				if (!mergedMap.has(kr.name)) {
					mergedMap.set(kr.name, kr);
				} else {
					const existing = mergedMap.get(kr.name);
					existing._keywordScore = kr._keywordScore;
					existing._matchFields = kr._matchFields;
				}
			}

			// 4. 综合评分（60% 向量 + 40% 关键词）
			let results = Array.from(mergedMap.values()).map(item => {
				const vectorScore = item._vectorScore || 0;
				const keywordScore = item._keywordScore || 0;
				const hybridScore = vectorScore * 0.6 + keywordScore * 0.4;
				return { ...item, _hybridScore: hybridScore, _vectorScore: vectorScore, _keywordScore: keywordScore };
			});

			// 5. 权威分加权排序
			try {
				const stats = recipeStats.getRecipeStats(projectRoot);
				const byFileEntries = Object.values(stats.byFile || {});
				
				results = results.map(item => {
					const key = path.basename(item.name);
					const entry = (stats.byFile || {})[key];
					const authorityScore = entry ? recipeStats.getAuthorityScore(entry, byFileEntries, {}) : 0;
					
					// 最终分数 = 混合分 70% + 权威分 30%
					const finalScore = item._hybridScore * 0.7 + (authorityScore || 0) * 0.3;
					
					return {
						...item,
						similarity: finalScore,
						authority: entry?.authority || 0,
						usageCount: (entry?.guardUsageCount || 0) + (entry?.humanUsageCount || 0) + (entry?.aiUsageCount || 0),
						authorityScore: Math.round((authorityScore || 0) * 100) / 100,
						stats: entry ? {
							authority: entry.authority ?? 0,
							guardUsageCount: entry.guardUsageCount ?? 0,
							humanUsageCount: entry.humanUsageCount ?? 0,
							aiUsageCount: entry.aiUsageCount ?? 0,
							authorityScore: Math.round(authorityScore * 100) / 100
						} : undefined
					};
				});
			} catch (e) {
				console.warn('[Hybrid Search] Authority scoring failed:', e.message);
			}

			// 6. 过滤（可选）
			if (category) {
				results = results.filter(r => {
					const meta = (r.content || '').match(/category:\s*(.*)/i);
					return meta && meta[1].toLowerCase().includes(category.toLowerCase());
				});
			}
			if (language) {
				results = results.filter(r => {
					const meta = (r.content || '').match(/language:\s*(.*)/i);
					return meta && meta[1].toLowerCase().includes(language.toLowerCase());
				});
			}

			// 7. 排序和限制
			results.sort((a, b) => b.similarity - a.similarity);
			results = results.slice(0, limit);

			// 8. 返回有效数据
			const cleanResults = results.map(r => ({
				name: r.name,
				content: r.content,
				similarity: Math.round(r.similarity * 100) / 100,
				authority: r.authority,
				usageCount: r.usageCount,
				stats: r.stats,
				matchType: r._vectorScore > r._keywordScore ? 'semantic' : 'keyword',
				metadata: r.metadata
			}));

			res.json({ 
				results: cleanResults,
				total: cleanResults.length,
				hasVector: vectorResults.length > 0,
				hasKeyword: keywordResults.length > 0,
				searchTime: Date.now()
			});
		} catch (err) {
			console.error('[API Error]', err);
			res.status(500).json({ error: err.message });
		}
	});

	// API: 语义搜索（保留向后兼容）
	app.post('/api/search/semantic', async (req, res) => {
		try {
			const { keyword, limit = 5 } = req.body;
			if (!keyword) return res.status(400).json({ error: 'Keyword is required' });

			const ai = await AiFactory.getProvider(projectRoot);
			if (!ai) return res.status(500).json({ error: 'AI Provider not configured' });

			const { getInstance } = require('../../../lib/context');
			const service = getInstance(projectRoot);
			const results = await service.search(keyword, { limit });

			res.json(results);
		} catch (err) {
			console.error('[API Error]', err);
			res.status(500).json({ error: err.message });
		}
	});
}

module.exports = {
	registerSearchRoutes,
};
